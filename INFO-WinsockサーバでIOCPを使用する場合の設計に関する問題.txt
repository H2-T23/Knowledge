[INFO]WinsockサーバでIOCPを使用する場合の設計に関する問題

この資料は、WindowsNT IOCP(I/O Completion Port)の入出力モデルについて既に理解し、
関連するAPIについての詳しい知識のユーザを対象としています。
IOCPについては、IOCPの実装と、IOCPを使用するために必要なAPIついて記載された
「Advanced Windows改訂第３版」の「第１５章 デバイスI/O」を参照してください。

IOCPを使用することにより、非常にパフォーマンスが高く、
スケーラビリティに優れたサーバプログラムを開発できます。
IOCPを直接サポートする機能がWinsock2に追加され、WindowsNTプラットフォームには
この機能が完全に実装されています。ただし、IOCPはすべてのWindowsNT入出力モデルの
中で最も難解で、実装が困難です。この資料では、IOCPを使用してより
ソケットサーバを設計するのに役立ついくつかのヒントを紹介します。

##詳細

###ヒント１
	WriteFileおよびReadFileなどのWin32ファイル入出力関数の上位で、
	WSASendおよびWSARecvなどのWinsock2 IOCP対応の関数を使用します。

	マイクロソフトベースのプロトコルプロバイダのソケットハンドルはIFSハンドルです。
	したがって、このハンドルを使用してWin32ファイル入出力呼び出しを行うことができます。
	ただし、プロトコルプロバイダとファイルシステムの相互作用により、
	カーネルモードとユーザモードの間の移行、スレッドコンテキストの切り替え、および
	パラメータのマーシャリングが多数発生し、パフォーマンスが大幅に低下します。
	IOCPにはWinsock2 IOCP対応の関数のみを使用してください。

	それ以外で、ReadFileとWriteFileでパラメータのマーシャリングおよびモードの移行が発生するのは、
	プロバイダによってWSAPROTOCOL_INFO構造体のdwServiceFlags1にXP1＿IFS_HANDLESビットが
	設定されていない場合のみです。

	注：これらのプロバイダでは、WSASendおよびWSARecvを使用した場合でもモードの移行が発生しますが、
	ReadFileおよびWriteFileではより高頻度でモードの移行が発生します。


###ヒント２
	同時実行を許可するワーカースレッドの数と起動するワーカースレッドの総数を指定します。

	ワーカースレッドの数とIOCPで使用される同時実行スレッドの数は同じではありません。
	IOCPで使用される同時実行スレッドは最大で２つまで、スレッドプールのワーカースレッド数は
	１０までです。
	プール内のワーカースレッドの数は、IOCPで使用される同時実行スレッドの数以上であるため、
	キューから取得した完了パケットを処理するワーカースレッドから、キュー内の他の入出力パケットの
	処理を遅らせることなく、Win32の任意の"wait"関数を呼び出すことができます。

	キューから取り出されるのを待っている完了パケットが存在する場合、
	別のワーカースレッドが起動されます。
	その後、最初のスレッドでwait終了の条件が満たされると、実行が再開します。
	このとき、実行できるスレッドの数はIOCPで許可されている同時実行スレッド数（NumberOfConcurrentThreadsなど）
	より多くなります。ただし、次のワーカースレッドがGetQueueCompletionStatusを呼び出して
	待機状態に入ったときに、このスレッドは起動されません。
	つまり、システムでは、同時実行ワーカースレッドがユーザの指定した数に保たれます。

	通常は、IOCP用のCPU１つに対して同時実行ワーカースレッドが１つあれば十分です。
	この設定を行うには、IOCPを最初に作成するときにCreateCompletionPort呼び出しの
	NumbberOfConcurrentThreadsに0を入力します。
	
###ヒント３
	キューから取得した完了パケットとポストされた入出力操作を関連付けます。

	完了パケットキューから取り出すときに、GetQueuedCompletionStatusにより入出力の完了キーと
	OVERLAPPED構造体が返されます。
	これら２つの構造体を使用して、ハンドルごとに、入出力操作ごとにそれぞれを情報を返す必要があります。
	ハンドル毎の情報を提供数する為に、IOCPにソケットを登録するときにには、
	ソケットハンドルを完了キーとして使用できます。
	入出力毎に操作を提供するには、アプリケーション固有の入出力の状態情報を含むように
	OVERLAPPED構造体を"拡張"します。
	また、重複した入出力毎に一意のOVERLAPPED構造体を使用するようにします。
	入出力が完了すると、重複した入出力構造体への同じポインタが返されます。


###ヒント４
	入出力完了パケットのキューへの入力処理

	入出力完了パケットがIOCPでキューに挿入される順序は、
	Winsock2入出力呼び出しの順序と必ずしも一致しません。
	さらに、Winsock2入出力呼び出しでSUCCESSまたはIO_PENDINGが返される場合、
	ソケットハンドルの開閉状態にかかわらず、完了パケットは入出力が完了したときに
	確実にIOCPのキューに挿入されます。
	ソケットハンドルを閉じると、それ以降のWSASend、WSASendTo、WSARecv、またはWSARecvFromの呼び出しは、
	SUCCESSおよびIO_PENDING以外のリターンコードを返して失敗し、完了パケットは生成されません。
	この場合、事前にポストされた入出力に対して、GetQueuedCompletionStatusを実行すると、
	返される完了パケットの状態は失敗になっていることがあります。

	IOCP自体を削除した場合、IOCPハンドル自体が無効になるため、
	IOCPに入出力をポストすることはできません。
	ただし、システムを構成するIOCPカーネルの構造は、正常にポストされた入出力がすべて
	完了するまで失われません。


###ヒント５
	IOCPのクリーンアップ

	IOCPのクリーンアップを実行するときに最も重要なことは、
	重複した入出力を使用するときと同様、入出力が完了するまでは、OVERLAPPED構造体を解放しないことです。
	OVERLAPPED構造体からの入出力が完了したかどうかはHasOverlappedIoCompletedマクロを使用することで検出できます。

	一般的に、サーバをシャットダウンする場合には、2つのケースがあります。
	１つ目の場合は、処理されていない入出力の完了状態にかかわらず、できる限り早くシャットダウンする場合です。
	２つ目の場合は、サーバをシャットダウンする際に、未処理の各入出力の完了状態を確認する必要がある場合です。

	最初のケースでは、PosQueueCompletionStatusをN回（Nはワーカースレッド数）呼び出すことにより、
	ワーカースレッドをすぐに終了するように通知する特別な完了パケットをポストし、
	すべてのソケットハンドラとそれに関連するOVERLAPPED構造体を閉じてから完了ポートを閉じます。
	ソケットを閉じると、このソケットで未処理の入出力はすべて速やかに完了します。

	２つ目のケースでは、すべての完了パケットが正常にキューから取り出されるように、
	既存のワーカースレッドを遅延させます。
	まず、すべてのソケットハンドルとIOCPを閉じます。
	ただし、未処理の入出力の件数カウントを保持して、ワーカースレッドが安全にスレッドを終了できるタイミングを
	認識できるようにする必要があります。
	キュー内に完了パケットが残っている限り、アクティブなワーカースレッドがなくなることはありません。
	このため、IOCPサーバのクリティカルセクションでグローバルな入出力カウンタを保持しても、
	パフォーマンスは予想されるほど低下しません。







概要
	この資料は、Windows NT IOCP (I/O Completion Port) の入出力モデルについて既に理解し、
	関連する API についての詳しい知識のあるユーザーを対象としています。
	IOCP については、IOCP の実装と、IOCP を使用するために必要な API について記載された
	『Advanced Windows 改訂第 3 版』の「第 15 章 デバイス I/O」 (Jeffery Richter) を参照してください。

	IOCPを使用することにより、非常にパフォーマンスが高く、
	スケーラビリティに優れたサーバー プログラムを開発できます。
	IOCPを直接サポートする機能がWinsock2に追加され、
	Windows NT プラットフォームにはこの機能が完全に実装されています。
	ただし、IOCPはすべてのWindowsNT入出力モデルの中で最も難解で、実装が困難です。
	この資料では、IOCPを使用してより優れたソケットサーバーを設計するのに役立ついくつかのヒントを紹介します。

詳細

ヒント 1 : 
	WriteFileおよびReadFileなどのWin32ファイル入出力関数の上位で、
	WSASendおよびWSARecvなどのWinsock2 IOCP対応の関数を使用します。

	マイクロソフトベースのプロトコルプロバイダのソケットハンドルはIFSハンドルです。
	したがって、このハンドルを使用してWin32ファイル入出力呼び出しを行うことができます。
	ただし、プロトコルプロバイダとファイルシステムの相互作用により、
	カーネルモードとユーザー モードの間の移行、スレッドコンテキストの切り替え、
	およびパラメータのマーシャリングが多数発生し、パフォーマンスが大幅に低下します。
	IOCPにはWinsock2 IOCP対応の関数のみを使用してください。

	それ以外で、ReadFileとWriteFileでパラメータのマーシャリングおよびモードの移行が発生するのは、
	プロバイダによってWSAPROTOCOL_INFO構造体のdwServiceFlags1に
	XP1_IFS_HANDLESビットが設定されていない場合のみです。

	注 : これらのプロバイダでは、
	WSASend および WSARecv を使用した場合でもモードの移行が発生しますが、
	ReadFile および WriteFile ではより高い頻度でモードの移行が発生します。



ヒント 2 : 
	同時実行を許可するワーカー スレッドの数と起動するワーカー スレッドの総数を指定します。

	ワーカー スレッドの数と IOCP で使用される同時実行スレッドの数は同じではありません。
	IOCP で使用される同時実行スレッドは最大で 2 つまで、
	スレッド プールのワーカー スレッド数は 10 までです。
	プール内のワーカー スレッドの数は、IOCP で使用される同時実行スレッドの数以上であるため、
	キューから取得した完了パケットを処理するワーカー スレッドから、
	キュー内の他の入出力パケットの処理を遅らせることなく、Win32 の任意の "wait" 関数を呼び出すことができます。

	キューから取り出されるのを待っている完了パケットが存在する場合、別のワーカー スレッドが起動されます。
	その後、最初のスレッドで wait 終了の条件が満たされると、実行が再開します。
	このとき、実行できるスレッドの数は IOCP で許可されている同時実行スレッド数 (NumberOfConcurrentThreads など) より多くなります。
	ただし、次のワーカー スレッドが GetQueueCompletionStatus を呼び出して待機状態に入ったときに、
	このスレッドは起動されません。
	つまり、システムでは、同時実行ワーカー スレッドがユーザーの指定した数に保たれます。

	通常は、IOCP 用の CPU 1 つに対して同時実行ワーカー スレッドが 1 つあれば十分です。
	この設定を行うには、IOCP を最初に作成するときに CreateIoCompletionPort 呼び出しの NumberOfConcurrentThreads に 0 を入力します。



ヒント 3 : 
	キューから取得した完了パケットとポストされた入出力操作を関連付けます。

	完了パケットをキューから取り出すときに、
	GetQueuedCompletionStatusにより入出力の完了キーとOVERLAPPED構造体が返されます。
	これら2つの構造体を使用して、ハンドル毎、入出力操作毎にそれぞれ情報を返す必要があります。
	ハンドル毎の情報を提供するために、IOCP にソケットを登録するときには、
	ソケット ハンドルを完了キーとして使用できます。
	入出力毎の操作を提供するには、
	アプリケーション固有の入出力の状態情報を含むようにOVERLAPPED構造体を"拡張"します。
	また、重複した入出力毎に一意のOVERLAPPED構造体を使用するようにします。
	入出力が完了すると、
	重複した入出力構造体への同じポインタが返されます。



ヒント 4 : 入出力完了パケットのキューへの入力処理

	入出力完了パケットがIOCPでキューに挿入される順序は、
	Winsock2入出力呼び出しの順序と必ずしも一致しません。
	さらに、Winsock2入出力呼び出しでSUCCESSまたはIO_PENDINGが返される場合、
	ソケット ハンドルの開閉状態にかかわらず、
	完了パケットは入出力が完了したときに確実にIOCPのキューに挿入されます。
	ソケット ハンドルを閉じると、それ以降の WSASend、WSASendTo、WSARecv、
	または WSARecvFrom の呼び出しは、SUCCESS および IO_PENDING 以外のリターンコードを返して失敗し、
	完了パケットは生成されません。
	この場合、事前にポストされた入出力に対してGetQueuedCompletionStatusを実行すると、
	返される完了パケットの状態は失敗になっていることがあります。

	IOCP自体を削除した場合、
	IOCPハンドル自体が無効になるため、IOCPに入出力をポストすることはできません。
	ただし、システムを構成するIOCPカーネルの構造は、
	正常にポストされた入出力がすべて完了するまで失われません。




ヒント 5 : IOCP のクリーンアップ

	IOCP のクリーンアップを実行するときに最も重要なことは、
	重複した入出力を使用するときと同様、
	入出力が完了するまでは OVERLAPPED 構造体を解放しないことです。
	OVERLAPPED構造体からの入出力が完了したかどうかは 
	HasOverlappedIoCompletedマクロを使用することで検出できます。

	一般的に、サーバーをシャットダウンする場合には、2 つのケースがあります。
	1 つ目の場合は、処理されていない入出力の完了状態にかかわらず、
	できる限り早くシャットダウンする場合です。
	2 つ目の場合は、サーバーをシャットダウンする際に、
	未処理の各入出力の完了状態を確認する必要がある場合です。

	最初のケースでは、PostQueueCompletionStatus を N 回 (N はワーカー スレッド数) 呼び出すことにより、
	ワーカー スレッドをすぐに終了するように通知する特別な完了パケットをポストし、
	すべてのソケット ハンドルとそれに関連する OVERLAPPED 構造体を閉じてから完了ポートを閉じます。
	ここでもHasOverlappedIoCompletedを使用して、
	OVERLAPPED 構造体を解放する前に構造体の完了状態を確認するようにします。
	ソケットを閉じると、このソケットで未処理の入出力はすべて速やかに完了します。

	2 番目のケースでは、すべての完了パケットが正常にキューから取り出されるように、
	既存のワーカー スレッドを遅延させます。
	まず、すべてのソケット ハンドルと IOCPを閉じます。
	ただし、未処理の入出力の件数カウンタを保持して、
	ワーカー スレッドが安全にスレッドを終了できるタイミングを認識できるようにする必要があります。
	キュー内に完了パケットが残っている限り、アクティブなワーカー スレッドがなくなることはありません。
	このため、IOCP サーバーのクリティカル セクションでグローバルな入出力カウンタを保護しても、
	パフォーマンスは予想されるほど低下しません。 
